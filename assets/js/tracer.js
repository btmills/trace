// Generated by CoffeeScript 1.4.0
(function() {
  var Range, Scope, Syntax, Tree, Variable, deselect, display, editor, parse, select, showChain, treeify,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Tree = (function() {

    function Tree(_parent, _root, children) {
      var child, _i, _len;
      this._parent = _parent;
      this._root = _root;
      this.root = __bind(this.root, this);

      this.parent = __bind(this.parent, this);

      this._children = [];
      if (children instanceof Array) {
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          child = children[_i];
          this.add(child);
        }
      }
    }

    Tree.prototype.parent = function(parent) {
      if (parent === void 0) {
        return this._parent;
      } else {
        this._parent = parent;
        return this;
      }
    };

    Tree.prototype.root = function(root) {
      if (root === void 0) {
        return this._root;
      } else {
        this._root = root;
        return this;
      }
    };

    Tree.prototype.add = function(child) {
      this._children.push(child instanceof Tree ? child.parent(this) : new Tree(this, child));
      return this;
    };

    Tree.prototype.toString = function(ind) {
      var child, i, str, _i, _len, _ref;
      if (ind == null) {
        ind = 0;
      }
      str = '';
      str += ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = 4 * ind; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(' ');
        }
        return _results;
      })()).join('');
      str += '(';
      str += this._root;
      if (this._children.length) {
        str += ', [';
        str += '\n';
        _ref = this._children;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          child = _ref[_i];
          str += child.toString(ind + 1) + ',\n';
        }
        str += ((function() {
          var _j, _ref1, _results;
          _results = [];
          for (i = _j = 0, _ref1 = 4 * ind; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
            _results.push(' ');
          }
          return _results;
        })()).join('');
        str += ']';
      }
      str += ')';
      return str;
    };

    Tree.prototype.toObject = function() {
      var child;
      return {
        root: this._root,
        children: (function() {
          var _i, _len, _ref, _results;
          _ref = this._children;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            _results.push(child.toObject());
          }
          return _results;
        }).call(this)
      };
    };

    Tree.prototype.toJSON = function() {
      return JSON.stringify(this.toObject(), null, 2);
    };

    return Tree;

  })();

  Range = ace.require('ace/range').Range;

  editor = ace.edit('code');

  editor.setTheme('ace/theme/monokai');

  editor.getSession().setMode('ace/mode/javascript');

  editor.setShowPrintMargin(false);

  editor.getSession().on('change', function(event) {
    try {
      return display(treeify(parse(editor.getValue())));
    } catch (err) {
      $('#chain').html();
      $('#tree').css('top', $('#chain').outerHeight());
      return $('#tree').html(err.toString());
    }
  });

  parse = function(code) {
    return esprima.parse(code, {
      range: true,
      loc: true
    });
  };

  showChain = function(tree) {
    var chain, cur, item, variable, vars, _i, _len, _ref;
    vars = [];
    cur = tree;
    while (cur != null) {
      _ref = cur.root().variables;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        variable = _ref[_i];
        if (!(((function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = vars.length; _j < _len1; _j++) {
            item = vars[_j];
            if (item.name === variable.name) {
              _results.push(item.name);
            }
          }
          return _results;
        })()).length > 0)) {
          vars.push(variable);
        }
      }
      cur = cur.parent();
    }
    chain = $('#chain').html('');
    $.each(vars, function(index, variable) {
      return item = $('<li>').addClass('variable').text(variable.name).on('hover', function(event) {
        switch (event.type) {
          case 'mouseenter':
            return select(variable.loc);
          case 'mouseleave':
            return deselect();
        }
      }).appendTo(chain);
    });
    return $('#tree').css('top', chain.outerHeight());
  };

  select = function(loc) {
    var a, b, c, d, _ref, _ref1;
    (_ref = loc.start, a = _ref.line, b = _ref.column), (_ref1 = loc.end, c = _ref1.line, d = _ref1.column);
    return editor.getSelection().setSelectionRange(new Range(a - 1, b, c - 1, d));
  };

  deselect = function() {
    return editor.clearSelection();
  };

  display = function(data) {
    var render;
    render = function(tree, nesting) {
      var child, scope, variables, _i, _len, _ref;
      if (nesting == null) {
        nesting = 0;
      }
      scope = $('<div>').addClass('scope').addClass("nested-" + nesting).on('click', function(event) {
        event.stopPropagation();
        return showChain(tree);
      });
      if (tree.root().variables.length) {
        variables = $('<ul>').addClass('variables').appendTo(scope);
        $.each(tree.root().variables, function(index, variable) {
          return $('<li>').addClass('variable').text(variable.name).on('hover', function(event) {
            switch (event.type) {
              case 'mouseenter':
                return select(variable.loc);
              case 'mouseleave':
                return deselect();
            }
          }).appendTo(variables);
        });
      }
      _ref = tree._children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        scope.append(render(child, nesting + 1));
      }
      return scope;
    };
    $('#chain').html('');
    $('#tree').css('top', $('#chain').outerHeight());
    return $('#tree').html(render(data));
  };

  Syntax = {
    ArrayExpression: ["elements"],
    AssignmentExpression: ["left", "right"],
    BinaryExpression: ["left", "right"],
    BlockStatement: ["body"],
    BreakStatement: ["label"],
    CallExpression: ["callee", "arguments"],
    CatchClause: ["param", "guard", "body"],
    ConditionalExpression: ["test", "alternate", "consequent"],
    ContinueStatement: ["label"],
    DebuggerStatement: [],
    DoWhileStatement: ["init", "test", "update", "body"],
    EmptyStatement: [],
    ExpressionStatement: ["expression"],
    ForInStatement: ["left", "right", "body"],
    ForStatement: ['init', 'test', 'update', "body"],
    FunctionDeclaration: ["id", "params", "defaults", "rest", "body"],
    FunctionExpression: ["id", "params", "defaults", "rest", "body"],
    Identifier: [],
    IfStatement: ["test", "consequent", "alternate"],
    LabeledStatement: ["label", "body"],
    Literal: [],
    LogicalExpression: ["left", "right"],
    MemberExpression: ["object", "property"],
    NewExpression: ["callee", "arguments"],
    ObjectExpression: ["properties"],
    Pattern: [],
    Program: ["body"],
    ReturnStatement: ["argument"],
    SequenceExpression: ["expressions"],
    SwitchCase: ["test", "consequent"],
    SwitchStatement: ["discriminant", "cases"],
    ThisExpression: [],
    ThrowStatement: ["argument"],
    TryStatement: ["block", "handler", "guardedHandlers", "finalizer"],
    UnaryExpression: ["argument"],
    UpdateExpression: ["argument"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["init"],
    WhileStatement: ["test", "body"],
    WithStatement: ["object", "body"]
  };

  Scope = (function() {

    function Scope(loc) {
      var _ref;
      this.loc = loc;
      if ((_ref = this.loc) == null) {
        this.loc = {
          start: {
            column: 0,
            line: 0
          },
          end: {
            column: 0,
            line: 0
          }
        };
      }
      this.range = [this.loc.start.line, this.loc.start.column, this.loc.end.line, this.loc.end.column];
      this.variables = [];
    }

    Scope.prototype.add = function(variable) {
      if (!(variable instanceof Variable)) {
        throw 'Variable must be an instance of Variable';
      }
      return this.variables.push(variable);
    };

    Scope.prototype.has = function(id) {
      var variable;
      return ((function() {
        var _i, _len, _ref, _results;
        _ref = this.variables;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          variable = _ref[_i];
          if (variable.name === id) {
            _results.push(variable.name);
          }
        }
        return _results;
      }).call(this)).length > 0;
    };

    return Scope;

  })();

  Variable = (function() {

    function Variable(name, loc) {
      var _ref;
      this.name = name;
      this.loc = loc;
      if ((_ref = this.loc) == null) {
        this.loc = {
          start: {
            column: 0,
            line: 0
          },
          end: {
            column: 0,
            line: 0
          }
        };
      }
      this.range = [this.loc.start.line, this.loc.start.column, this.loc.end.line, this.loc.end.column];
    }

    return Variable;

  })();

  treeify = function(block, scope, declaration) {
    var el, local, prop, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    if (!block) {
      return scope;
    }
    if (block instanceof Array) {
      for (_i = 0, _len = block.length; _i < _len; _i++) {
        el = block[_i];
        treeify(el, scope, declaration);
      }
      return scope;
    }
    switch (block.type) {
      case 'Identifier':
        if (declaration) {
          if (!scope.root().has(block.name)) {
            scope.root().add(new Variable(block.name, block.loc));
          } else {
            console.log('Variable %s already defined', block.name);
          }
        }
        break;
      case 'FunctionDeclaration':
      case 'FunctionExpression':
        local = new Tree(scope, new Scope(block.loc));
        treeify(block.id, scope);
        treeify(block.params, local, true);
        treeify(block.defaults, local);
        treeify(block.rest, local, true);
        treeify(block.body, local);
        scope.add(local);
        break;
      case 'ObjectExpression':
        _ref = block.properties;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          prop = _ref[_j];
          treeify(prop.value, scope);
        }
        break;
      case 'Program':
        scope = new Tree(null, new Scope);
        treeify(block.body, scope);
        break;
      case 'VariableDeclarator':
        treeify(block.id, scope, true);
        treeify(block.init, scope);
        break;
      default:
        if (Syntax.hasOwnProperty(block.type)) {
          _ref1 = Syntax[block.type];
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            prop = _ref1[_k];
            treeify(block[prop], scope);
          }
        } else {

        }
    }
    return scope;
  };

}).call(this);
